// STABILITY TESTS FOR LOCATION FLOW
// Generated by MIEL-LOCATION-REPAIR Agent

import { renderHook, act, waitFor } from "@testing-library/react";
import { useLocationFlow } from "../useLocationFlow";
import * as memberActions from "@/app/actions/memberActions";
import * as locationUtils from "@/lib/locationUtils";

// Mock Next.js navigation hooks
const mockReplace = jest.fn();
const mockSearchParams = new URLSearchParams();

jest.mock("next/navigation", () => ({
  useSearchParams: () => mockSearchParams,
  useRouter: () => ({ replace: mockReplace }),
  usePathname: () => "/members",
}));

jest.mock("@/app/actions/memberActions");
jest.mock("@/lib/locationUtils");

describe("useLocationFlow - Stability Tests", () => {
  beforeEach(() => {
    jest.clearAllMocks();
    mockSearchParams.delete("userLat");
    mockSearchParams.delete("userLon");
    mockSearchParams.delete("sortByDistance");
    mockReplace.mockClear();
  });

  // TEST 1: State Machine Transition Test
  describe("State Machine Transitions", () => {
    it("should transition through states in correct order when URL has no params", async () => {
      const states: string[] = [];

      // Mock DB location available
      (
        memberActions.getCurrentUserLocationStatus as jest.Mock
      ).mockResolvedValue({
        hasLocation: true,
        locationEnabled: true,
        coordinates: { latitude: 32.0853, longitude: 34.7818 },
      });

      // Mock browser permission denied
      (locationUtils.checkLocationPermission as jest.Mock).mockResolvedValue(
        false
      );

      const { result } = renderHook(() => useLocationFlow());

      // Track state changes
      await waitFor(() => {
        states.push(result.current.locationState);
      });

      await waitFor(
        () => {
          expect(result.current.locationState).toBe("readyToQuery");
        },
        { timeout: 5000 }
      );

      // Check no backwards transitions occurred
      const visitedStates = new Set<string>();
      for (const state of states) {
        if (visitedStates.has(state)) {
          throw new Error(`Backwards transition detected: revisited ${state}`);
        }
        visitedStates.add(state);
      }

      expect(states).toContain("readyToQuery");
    });

    it("should skip to readyToQuery immediately when URL has location params", async () => {
      // Set URL params
      mockSearchParams.set("userLat", "32.0853");
      mockSearchParams.set("userLon", "34.7818");

      const { result } = renderHook(() => useLocationFlow());

      await waitFor(
        () => {
          expect(result.current.locationState).toBe("readyToQuery");
        },
        { timeout: 1000 }
      );

      // Should NOT have called DB or browser location APIs
      expect(memberActions.getCurrentUserLocationStatus).not.toHaveBeenCalled();
      expect(locationUtils.checkLocationPermission).not.toHaveBeenCalled();
    });
  });

  // TEST 2: URL Sync Guard Test
  describe("URL Update Guards", () => {
    it("should call router.replace EXACTLY ONCE when transitioning to usingBrowserLocation", async () => {
      // Mock browser location available
      (
        memberActions.getCurrentUserLocationStatus as jest.Mock
      ).mockResolvedValue({
        hasLocation: true,
        locationEnabled: true,
        coordinates: { latitude: 32.0, longitude: 34.0 },
      });

      (locationUtils.checkLocationPermission as jest.Mock).mockResolvedValue(
        true
      );
      (locationUtils.getCurrentLocation as jest.Mock).mockResolvedValue({
        granted: true,
        coordinates: { latitude: 32.0853, longitude: 34.7818 },
      });

      renderHook(() => useLocationFlow());

      await waitFor(
        () => {
          expect(mockReplace).toHaveBeenCalledTimes(1);
        },
        { timeout: 5000 }
      );

      // Wait additional time to ensure no duplicate calls
      await new Promise((resolve) => setTimeout(resolve, 500));

      // Verify still only called once
      expect(mockReplace).toHaveBeenCalledTimes(1);

      // Verify URL params are correct
      const callArgs = mockReplace.mock.calls[0][0];
      expect(callArgs).toContain("userLat=32.0853");
      expect(callArgs).toContain("userLon=34.7818");
      expect(callArgs).toContain("sortByDistance=true");
    });

    it("should call router.replace EXACTLY ONCE when transitioning to usingDbLocation", async () => {
      (
        memberActions.getCurrentUserLocationStatus as jest.Mock
      ).mockResolvedValue({
        hasLocation: true,
        locationEnabled: true,
        coordinates: { latitude: 32.0853, longitude: 34.7818 },
      });

      // Mock browser permission denied (will use DB location)
      (locationUtils.checkLocationPermission as jest.Mock).mockResolvedValue(
        false
      );

      renderHook(() => useLocationFlow());

      await waitFor(
        () => {
          expect(mockReplace).toHaveBeenCalledTimes(1);
        },
        { timeout: 5000 }
      );

      // Wait additional time to ensure no duplicate calls
      await new Promise((resolve) => setTimeout(resolve, 500));

      // Verify still only called once
      expect(mockReplace).toHaveBeenCalledTimes(1);
    });

    it("should NOT call router.replace if URL already has location params", async () => {
      mockSearchParams.set("userLat", "32.0853");
      mockSearchParams.set("userLon", "34.7818");

      renderHook(() => useLocationFlow());

      await waitFor(
        () => {
          expect(mockReplace).not.toHaveBeenCalled();
        },
        { timeout: 1000 }
      );
    });
  });

  // TEST 3: Loop Prevention Test
  describe("Infinite Loop Prevention", () => {
    it("should NOT trigger infinite re-renders when URL updates", async () => {
      let renderCount = 0;

      (
        memberActions.getCurrentUserLocationStatus as jest.Mock
      ).mockResolvedValue({
        hasLocation: true,
        locationEnabled: true,
        coordinates: { latitude: 32.0853, longitude: 34.7818 },
      });

      (locationUtils.checkLocationPermission as jest.Mock).mockResolvedValue(
        false
      );

      const { result } = renderHook(() => {
        renderCount++;
        return useLocationFlow();
      });

      await waitFor(
        () => {
          expect(result.current.locationState).toBe("readyToQuery");
        },
        { timeout: 5000 }
      );

      // Wait to ensure no additional renders
      await new Promise((resolve) => setTimeout(resolve, 1000));

      // Should have reasonable number of renders (no infinite loop)
      // Expected: ~8-10 renders for state transitions
      expect(renderCount).toBeLessThan(15);
      console.log(`Total renders: ${renderCount}`);
    });
  });

  // TEST 4: Render Stability Test
  describe("Render Count Test", () => {
    it("should complete location flow in no more than 10 renders", async () => {
      let renderCount = 0;

      (
        memberActions.getCurrentUserLocationStatus as jest.Mock
      ).mockResolvedValue({
        hasLocation: true,
        locationEnabled: true,
        coordinates: { latitude: 32.0853, longitude: 34.7818 },
      });

      (locationUtils.checkLocationPermission as jest.Mock).mockResolvedValue(
        false
      );

      const { result } = renderHook(() => {
        renderCount++;
        return useLocationFlow();
      });

      await waitFor(
        () => {
          expect(result.current.locationState).toBe("readyToQuery");
        },
        { timeout: 5000 }
      );

      // FIX SUCCESS: Should be <= 10 renders (was infinite before patch)
      expect(renderCount).toBeLessThanOrEqual(10);
      console.log(`Render count (should be ≤10): ${renderCount}`);
    });

    it("should complete in 3 renders when URL has params (fast path)", async () => {
      let renderCount = 0;

      mockSearchParams.set("userLat", "32.0853");
      mockSearchParams.set("userLon", "34.7818");

      const { result } = renderHook(() => {
        renderCount++;
        return useLocationFlow();
      });

      await waitFor(
        () => {
          expect(result.current.locationState).toBe("readyToQuery");
        },
        { timeout: 1000 }
      );

      // Fast path: should be very few renders
      expect(renderCount).toBeLessThanOrEqual(4);
      console.log(`Fast path render count (should be ≤4): ${renderCount}`);
    });
  });

  // TEST 5: Auth/Session Warmup Test
  describe("Session Warmup", () => {
    it("should wait for session before calling DB on first mount", async () => {
      const callTimes: number[] = [];

      (
        memberActions.getCurrentUserLocationStatus as jest.Mock
      ).mockImplementation(async () => {
        callTimes.push(Date.now());
        return {
          hasLocation: false,
          locationEnabled: false,
          coordinates: null,
        };
      });

      const startTime = Date.now();

      renderHook(() => useLocationFlow());

      await waitFor(
        () => {
          expect(memberActions.getCurrentUserLocationStatus).toHaveBeenCalled();
        },
        { timeout: 3000 }
      );

      const dbCallDelay = callTimes[0] - startTime;

      // Should have waited at least 100ms for session warmup
      expect(dbCallDelay).toBeGreaterThanOrEqual(100);
      console.log(`DB call delay (should be ≥100ms): ${dbCallDelay}ms`);
    });
  });

  // TEST 6: Timeout Handling
  describe("Timeout Behavior", () => {
    it("should fallback to noLocationAvailable after 8 seconds", async () => {
      // Mock hanging DB call
      (
        memberActions.getCurrentUserLocationStatus as jest.Mock
      ).mockImplementation(
        () => new Promise(() => {}) // Never resolves
      );

      const { result } = renderHook(() => useLocationFlow());

      await waitFor(
        () => {
          expect(result.current.locationState).toBe("noLocationAvailable");
        },
        { timeout: 9000 }
      );

      expect(result.current.showLocationModal).toBe(true);
    });
  });

  // TEST 7: Modal Callback Test
  describe("handleLocationGranted", () => {
    it("should update URL and internal location when user grants permission", async () => {
      mockSearchParams.set("requestLocation", "true");

      const { result } = renderHook(() => useLocationFlow());

      await waitFor(() => {
        expect(result.current.showLocationModal).toBe(true);
      });

      // User grants location
      act(() => {
        result.current.handleLocationGranted({
          latitude: 32.0853,
          longitude: 34.7818,
        });
      });

      expect(mockReplace).toHaveBeenCalled();
      const callArgs = mockReplace.mock.calls[0][0];
      expect(callArgs).toContain("userLat=32.0853");
      expect(callArgs).toContain("userLon=34.7818");
      expect(callArgs).not.toContain("requestLocation");
    });
  });
});
